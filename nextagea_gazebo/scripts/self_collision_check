#!/usr/bin/env python
# Self-collision, velocity & acceleration limit checker for Nextage platform

import pyexotica as exo
from pyexotica.publish_trajectory import *
import signal
import sys
import rospy
import numpy as np
from pyexotica.tools import check_whether_trajectory_is_collision_free_by_subsampling, get_colliding_links
from trajectory_msgs.msg import JointTrajectory
from control_msgs.msg import JointTrajectoryControllerState
from xml.dom.minidom import parse
from rospkg import RosPack

class colours:
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'

class SelfCollisionCheck:
    '''Trajectory checker for the Nextage platform - checks self-collision, velocity and acceleration limits. 
    Node sits in front of trajectory controllers and filters out potentially harmful trajectories that may cause 
    self-collisions'''

    def __init__(self, MODE, CONTROLLER_TYPE):
        # Initial setup and sub/pub to nodes
        self.controller_type = CONTROLLER_TYPE
        self.input_traj = rospy.Subscriber(rospy.resolve_name("~traj_input"), JointTrajectory, self.input_callback, queue_size=1)
        self.output_traj = rospy.Publisher(rospy.resolve_name("~traj_output"), JointTrajectory, queue_size=1)
        self.arm_info = rospy.Subscriber(rospy.resolve_name("~arm_input"), JointTrajectoryControllerState, self.arm_callback, queue_size=1)

        # Setup EXOTica scene with corresponding JointGroup
        init = exo.Initializers.SceneInitializer()
        init[1]['JointGroup'] = str(self.controller_type)
        init[1]['URDF'] = '{nextagea_description}/urdf/NextageAOpen.urdf'
        init[1]['SRDF'] = '{nextagea_moveit_config}/config/NextageAOpen.srdf'
        init[1]['AlwaysUpdateCollisionScene'] = True
        init[1]['CollisionScene'] = 'CollisionSceneFCLLatest'
        self.scene = exo.Setup.create_scene(init)
        
        # Get velocity limits
        self.velocity_limits = self.scene.get_kinematic_tree().get_velocity_limits()
        # Get acceleration limits from the URDF - not part of the URDF standard and so must be manually retrieved
        rospack = RosPack()
        urdf = parse(rospack.get_path("nextagea_description") + "/urdf/NextageAOpen.urdf")
        joints = urdf.getElementsByTagName("joint")[-15:] # Nextage has 15 joints: 1 CHEST, 2 HEAD, 6 LARM, 6 RARM
        all_acceleration_limits = [float(joint.getElementsByTagName("limit")[0].getAttribute("acceleration")) for joint in joints]

        # Set names for joint group and select acceleration limits to match
        if rospy.resolve_name("~traj_input") == "/collision_botharms_controller/command":
            self.names = ['LARM_JOINT0', 'LARM_JOINT1', 'LARM_JOINT2', 'LARM_JOINT3', 'LARM_JOINT4', 'LARM_JOINT5', 'RARM_JOINT0', 'RARM_JOINT1', 'RARM_JOINT2', 'RARM_JOINT3', 'RARM_JOINT4', 'RARM_JOINT5']
            self.acceleration_limits = np.array(all_acceleration_limits[-12:])
        elif rospy.resolve_name("~traj_input") == "/collision_rarm_controller/command":
            self.names = ['RARM_JOINT0', 'RARM_JOINT1', 'RARM_JOINT2', 'RARM_JOINT3', 'RARM_JOINT4', 'RARM_JOINT5']
            self.acceleration_limits = np.array(all_acceleration_limits[-6:])
        else:
            self.names = ['LARM_JOINT0', 'LARM_JOINT1', 'LARM_JOINT2', 'LARM_JOINT3', 'LARM_JOINT4', 'LARM_JOINT5']
            self.acceleration_limits = np.array(all_acceleration_limits[3:9])

        self.mode = MODE
        self.check_trajectory = False
        self.rate = rospy.Rate(10)

    def input_callback(self, data):
        # If a trajectory is not currently being processed, get data and check
        if self.check_trajectory == False:
            self.check_trajectory = True
            self.trajectory_message = data
    
    def arm_callback(self, data):
        # Get current joint states
        self.arm_state = data
    
    def check_trajectory_velocities(self, arm_state, velocity_limits, trajectory_message):
        points = trajectory_message.points

        # Get starting position
        pos = [list(arm_state.actual.positions)]
        t = [0]
        for p in points:
            t.append(p.time_from_start.to_sec())
            pos.append(p.positions)

        # Calculate velocities, add 0 row to start for t=0
        velocities = np.true_divide(np.diff(pos, axis=0), np.diff(t)[:,None])
        velocities = np.vstack((np.zeros(np.size(velocities, 1)), velocities))
        velocity_check = (velocities < velocity_limits) & (velocities > -velocity_limits)
        check_result = velocity_check.all()

        # Identify failures & their timestamps
        index = np.where(velocity_check == False)
        timestamps = []
        for pose in index[0]:
            timestamps.append(t[pose])
        violations = np.column_stack((np.array(timestamps), index[1]))

        return (check_result, violations)

    def check_trajectory_accelerations(self, arm_state, acceleration_limits, trajectory_message):
        points = trajectory_message.points

        # Get starting position
        pos = [list(arm_state.actual.positions)]
        t = [0]
        for p in points:
            t.append(p.time_from_start.to_sec())
            pos.append(p.positions)

        # Calculate velocities and then accelerations, add 0 row to start for t=0
        velocities = np.true_divide(np.diff(pos, axis=0), np.diff(t)[:,None])
        velocities = np.vstack((np.zeros(np.size(velocities, 1)), velocities))
        accelerations = np.true_divide(np.diff(velocities, axis=0), np.diff(t)[:,None])
        accelerations = np.vstack((np.zeros(np.size(accelerations, 1)), accelerations))
        acceleration_check = (accelerations < acceleration_limits) & (accelerations > -acceleration_limits)
        check_result = acceleration_check.all()

        # Identify failures & their timestamps
        index = np.where(acceleration_check == False)
        timestamps = []
        for pose in index[0]:
            timestamps.append(t[pose])
        violations = np.column_stack((np.array(timestamps), index[1]))

        return (check_result, violations)

    def check_trajectory_collisions(self, scene, arm_state, joint_names, trajectory_message):
        # Find robot's current state
        current_arms = list(arm_state.actual.positions)

        # Update model with current joint positions
        joint_dict = {name : current_arms[i] for i, name in enumerate(joint_names)}
        scene.set_model_state_map(joint_dict)

        # Strip JointTrajectory down to be in EXOTica solution form
        list_traj = [current_arms]
        for i in range(0, len(trajectory_message.points)):
            list_traj.append(list(trajectory_message.points[i].positions))
        exotica_traj = np.array([np.array(x) for x in list_traj])

        return check_whether_trajectory_is_collision_free_by_subsampling(scene, exotica_traj)

    def spin(self):
        while not rospy.is_shutdown():
            try:
            if self.check_trajectory:

                traj_check = self.check_trajectory_collisions(self.scene, self.arm_state, self.names, self.trajectory_message)
                vel_check, vel_vals = self.check_trajectory_velocities(self.arm_state, self.velocity_limits, self.trajectory_message)
                accel_check, accel_vals = self.check_trajectory_accelerations(self.arm_state, self.acceleration_limits, self.trajectory_message)

                # Checks in following order: self-collision, velocity limits, acceleration limits
                if traj_check and vel_check and accel_check:
                    # Pass through trajectory
                    self.output_traj.publish(self.trajectory_message)

                # If warn, pass trajectory, if error withold trajectory
                elif not traj_check:
                    if self.mode == 'warn':
                        print(colours.WARNING + "[WARN] Self-collision detected on following links:")
                        get_colliding_links(self.scene)
                        print(colours.ENDC)
                        self.output_traj.publish(self.trajectory_message)
                    elif self.mode == 'error':
                        print(colours.FAIL + "[ERROR] Self-collision detected on following links:")
                        get_colliding_links(self.scene)
                        print(colours.ENDC)

                elif not vel_check:
                    if self.mode == 'warn':
                        print(colours.WARNING + "[WARN] Velocity limits exceeded at following times and links:")
                        for pose in vel_vals:
                            print(self.names[int(pose[1])] + " at t = " + str(pose[0]))
                        print(colours.ENDC)
                        self.output_traj.publish(self.trajectory_message)
                    elif self.mode == 'error':
                        print(colours.FAIL + "[ERROR] Velocity limits exceeded:")
                        for pose in vel_vals:
                            print(self.names[int(pose[1])] + " at t = " + str(pose[0]))
                        print(colours.ENDC)

                elif not accel_check:
                    if self.mode == 'warn':
                        print(colours.WARNING + "[WARN] Acceleration limits exceeded at following times and links:")
                        for pose in accel_vals:
                            print(self.names[int(pose[1])] + " at t = " + str(pose[0]))
                        print(colours.ENDC)
                        self.output_traj.publish(self.trajectory_message)
                    elif self.mode == 'error':
                        print(colours.FAIL + "[ERROR] Acceleration limits exceeded:")
                        for pose in accel_vals:
                            print(self.names[int(pose[1])] + " at t = " + str(pose[0]))
                        print(colours.ENDC)
                
                self.check_trajectory = False

            except Exception as e:
                print(colours.FAIL + "[ERROR] Self-collision check failed due to:")
                print(e)
                print(colours.ENDC)
                self.check_trajectory = False

            self.rate.sleep()


def main(args):

    # Get controller_type and mode parameters
    valid_mode = ["warn", "error"]
    valid_type = ["botharms", "rarm", "larm"]

    MODE = rospy.get_param("/self_collision_check/collision_mode")
    CONTROLLER_TYPE = rospy.get_param("/self_collision_check/controller_type")
    if MODE not in valid_mode:
        print("Detected self_collision_check mode: " + MODE)
        print("Invalid collision mode! Use only the following: " + str(valid_mode))
        exit(1)
    if CONTROLLER_TYPE not in valid_type:
        print("Detected self_collision_check controller type: " + CONTROLLER_TYPE)
        print("Invalid controller type! Use only the following: " + str(valid_type))
        exit(1)  

    rospy.init_node('self_collision_check')
    col = SelfCollisionCheck(MODE, CONTROLLER_TYPE)
    try:
        col.spin()
    except KeyboardInterrupt:
        print("Shutting down")

if __name__ == '__main__':
    main(sys.argv)